{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE StrictData #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- Derived from AWS service descriptions, licensed under Apache 2.0.

-- |
-- Module      : Amazonka.SecurityLake.CreateDataLake
-- Copyright   : (c) 2013-2023 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+amazonka@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
-- Initializes an Amazon Security Lake instance with the provided (or
-- default) configuration. You can enable Security Lake in Amazon Web
-- Services Regions with customized settings before enabling log collection
-- in Regions. By default, the @CreateDataLake@ Security Lake in all
-- Regions. To specify particular Regions, configure these Regions using
-- the @configurations@ parameter. If you have already enabled Security
-- Lake in a Region when you call this command, the command will update the
-- Region if you provide new configuration parameters. If you have not
-- already enabled Security Lake in the Region when you call this API, it
-- will set up the data lake in the Region with the specified
-- configurations.
--
-- When you enable Security Lake, it starts ingesting security data after
-- the @CreateAwsLogSource@ call. This includes ingesting security data
-- from sources, storing data, and making data accessible to subscribers.
-- Security Lake also enables all the existing settings and resources that
-- it stores or maintains for your Amazon Web Services account in the
-- current Region, including security log and event data. For more
-- information, see the
-- <https://docs.aws.amazon.com/security-lake/latest/userguide/what-is-security-lake.html Amazon Security Lake User Guide>.
module Amazonka.SecurityLake.CreateDataLake
  ( -- * Creating a Request
    CreateDataLake (..),
    newCreateDataLake,

    -- * Request Lenses
    createDataLake_configurations,
    createDataLake_metaStoreManagerRoleArn,

    -- * Destructuring the Response
    CreateDataLakeResponse (..),
    newCreateDataLakeResponse,

    -- * Response Lenses
    createDataLakeResponse_dataLakes,
    createDataLakeResponse_httpStatus,
  )
where

import qualified Amazonka.Core as Core
import qualified Amazonka.Core.Lens.Internal as Lens
import qualified Amazonka.Data as Data
import qualified Amazonka.Prelude as Prelude
import qualified Amazonka.Request as Request
import qualified Amazonka.Response as Response
import Amazonka.SecurityLake.Types

-- | /See:/ 'newCreateDataLake' smart constructor.
data CreateDataLake = CreateDataLake'
  { -- | Specify the Region or Regions that will contribute data to the rollup
    -- region.
    configurations :: [DataLakeConfiguration],
    -- | The Amazon Resource Name (ARN) used to create and update the Glue table.
    -- This table contains partitions generated by the ingestion and
    -- normalization of Amazon Web Services log sources and custom sources.
    metaStoreManagerRoleArn :: Prelude.Text
  }
  deriving (Prelude.Eq, Prelude.Read, Prelude.Show, Prelude.Generic)

-- |
-- Create a value of 'CreateDataLake' with all optional fields omitted.
--
-- Use <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/optics optics> to modify other optional fields.
--
-- The following record fields are available, with the corresponding lenses provided
-- for backwards compatibility:
--
-- 'configurations', 'createDataLake_configurations' - Specify the Region or Regions that will contribute data to the rollup
-- region.
--
-- 'metaStoreManagerRoleArn', 'createDataLake_metaStoreManagerRoleArn' - The Amazon Resource Name (ARN) used to create and update the Glue table.
-- This table contains partitions generated by the ingestion and
-- normalization of Amazon Web Services log sources and custom sources.
newCreateDataLake ::
  -- | 'metaStoreManagerRoleArn'
  Prelude.Text ->
  CreateDataLake
newCreateDataLake pMetaStoreManagerRoleArn_ =
  CreateDataLake'
    { configurations = Prelude.mempty,
      metaStoreManagerRoleArn = pMetaStoreManagerRoleArn_
    }

-- | Specify the Region or Regions that will contribute data to the rollup
-- region.
createDataLake_configurations :: Lens.Lens' CreateDataLake [DataLakeConfiguration]
createDataLake_configurations = Lens.lens (\CreateDataLake' {configurations} -> configurations) (\s@CreateDataLake' {} a -> s {configurations = a} :: CreateDataLake) Prelude.. Lens.coerced

-- | The Amazon Resource Name (ARN) used to create and update the Glue table.
-- This table contains partitions generated by the ingestion and
-- normalization of Amazon Web Services log sources and custom sources.
createDataLake_metaStoreManagerRoleArn :: Lens.Lens' CreateDataLake Prelude.Text
createDataLake_metaStoreManagerRoleArn = Lens.lens (\CreateDataLake' {metaStoreManagerRoleArn} -> metaStoreManagerRoleArn) (\s@CreateDataLake' {} a -> s {metaStoreManagerRoleArn = a} :: CreateDataLake)

instance Core.AWSRequest CreateDataLake where
  type
    AWSResponse CreateDataLake =
      CreateDataLakeResponse
  request overrides =
    Request.postJSON (overrides defaultService)
  response =
    Response.receiveJSON
      ( \s h x ->
          CreateDataLakeResponse'
            Prelude.<$> (x Data..?> "dataLakes" Core..!@ Prelude.mempty)
            Prelude.<*> (Prelude.pure (Prelude.fromEnum s))
      )

instance Prelude.Hashable CreateDataLake where
  hashWithSalt _salt CreateDataLake' {..} =
    _salt
      `Prelude.hashWithSalt` configurations
      `Prelude.hashWithSalt` metaStoreManagerRoleArn

instance Prelude.NFData CreateDataLake where
  rnf CreateDataLake' {..} =
    Prelude.rnf configurations
      `Prelude.seq` Prelude.rnf metaStoreManagerRoleArn

instance Data.ToHeaders CreateDataLake where
  toHeaders =
    Prelude.const
      ( Prelude.mconcat
          [ "Content-Type"
              Data.=# ( "application/x-amz-json-1.1" ::
                          Prelude.ByteString
                      )
          ]
      )

instance Data.ToJSON CreateDataLake where
  toJSON CreateDataLake' {..} =
    Data.object
      ( Prelude.catMaybes
          [ Prelude.Just
              ("configurations" Data..= configurations),
            Prelude.Just
              ( "metaStoreManagerRoleArn"
                  Data..= metaStoreManagerRoleArn
              )
          ]
      )

instance Data.ToPath CreateDataLake where
  toPath = Prelude.const "/v1/datalake"

instance Data.ToQuery CreateDataLake where
  toQuery = Prelude.const Prelude.mempty

-- | /See:/ 'newCreateDataLakeResponse' smart constructor.
data CreateDataLakeResponse = CreateDataLakeResponse'
  { -- | The created Security Lake configuration object.
    dataLakes :: Prelude.Maybe [DataLakeResource],
    -- | The response's http status code.
    httpStatus :: Prelude.Int
  }
  deriving (Prelude.Eq, Prelude.Read, Prelude.Show, Prelude.Generic)

-- |
-- Create a value of 'CreateDataLakeResponse' with all optional fields omitted.
--
-- Use <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/optics optics> to modify other optional fields.
--
-- The following record fields are available, with the corresponding lenses provided
-- for backwards compatibility:
--
-- 'dataLakes', 'createDataLakeResponse_dataLakes' - The created Security Lake configuration object.
--
-- 'httpStatus', 'createDataLakeResponse_httpStatus' - The response's http status code.
newCreateDataLakeResponse ::
  -- | 'httpStatus'
  Prelude.Int ->
  CreateDataLakeResponse
newCreateDataLakeResponse pHttpStatus_ =
  CreateDataLakeResponse'
    { dataLakes =
        Prelude.Nothing,
      httpStatus = pHttpStatus_
    }

-- | The created Security Lake configuration object.
createDataLakeResponse_dataLakes :: Lens.Lens' CreateDataLakeResponse (Prelude.Maybe [DataLakeResource])
createDataLakeResponse_dataLakes = Lens.lens (\CreateDataLakeResponse' {dataLakes} -> dataLakes) (\s@CreateDataLakeResponse' {} a -> s {dataLakes = a} :: CreateDataLakeResponse) Prelude.. Lens.mapping Lens.coerced

-- | The response's http status code.
createDataLakeResponse_httpStatus :: Lens.Lens' CreateDataLakeResponse Prelude.Int
createDataLakeResponse_httpStatus = Lens.lens (\CreateDataLakeResponse' {httpStatus} -> httpStatus) (\s@CreateDataLakeResponse' {} a -> s {httpStatus = a} :: CreateDataLakeResponse)

instance Prelude.NFData CreateDataLakeResponse where
  rnf CreateDataLakeResponse' {..} =
    Prelude.rnf dataLakes
      `Prelude.seq` Prelude.rnf httpStatus
