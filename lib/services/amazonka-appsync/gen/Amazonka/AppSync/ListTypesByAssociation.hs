{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE StrictData #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- Derived from AWS service descriptions, licensed under Apache 2.0.

-- |
-- Module      : Amazonka.AppSync.ListTypesByAssociation
-- Copyright   : (c) 2013-2023 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+amazonka@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
-- Lists @Type@ objects by the source API association ID.
module Amazonka.AppSync.ListTypesByAssociation
  ( -- * Creating a Request
    ListTypesByAssociation (..),
    newListTypesByAssociation,

    -- * Request Lenses
    listTypesByAssociation_maxResults,
    listTypesByAssociation_nextToken,
    listTypesByAssociation_mergedApiIdentifier,
    listTypesByAssociation_associationId,
    listTypesByAssociation_format,

    -- * Destructuring the Response
    ListTypesByAssociationResponse (..),
    newListTypesByAssociationResponse,

    -- * Response Lenses
    listTypesByAssociationResponse_nextToken,
    listTypesByAssociationResponse_types,
    listTypesByAssociationResponse_httpStatus,
  )
where

import Amazonka.AppSync.Types
import qualified Amazonka.Core as Core
import qualified Amazonka.Core.Lens.Internal as Lens
import qualified Amazonka.Data as Data
import qualified Amazonka.Prelude as Prelude
import qualified Amazonka.Request as Request
import qualified Amazonka.Response as Response

-- | /See:/ 'newListTypesByAssociation' smart constructor.
data ListTypesByAssociation = ListTypesByAssociation'
  { -- | The maximum number of results that you want the request to return.
    maxResults :: Prelude.Maybe Prelude.Natural,
    -- | An identifier that was returned from the previous call to this
    -- operation, which you can use to return the next set of items in the
    -- list.
    nextToken :: Prelude.Maybe Prelude.Text,
    -- | The identifier of the AppSync Merged API. This is generated by the
    -- AppSync service. In most cases, Merged APIs (especially in your account)
    -- only require the API ID value or ARN of the merged API. However, Merged
    -- APIs in other accounts (cross-account use cases) strictly require the
    -- full resource ARN of the merged API.
    mergedApiIdentifier :: Prelude.Text,
    -- | The ID generated by the AppSync service for the source API association.
    associationId :: Prelude.Text,
    -- | The format type.
    format :: TypeDefinitionFormat
  }
  deriving (Prelude.Eq, Prelude.Read, Prelude.Show, Prelude.Generic)

-- |
-- Create a value of 'ListTypesByAssociation' with all optional fields omitted.
--
-- Use <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/optics optics> to modify other optional fields.
--
-- The following record fields are available, with the corresponding lenses provided
-- for backwards compatibility:
--
-- 'maxResults', 'listTypesByAssociation_maxResults' - The maximum number of results that you want the request to return.
--
-- 'nextToken', 'listTypesByAssociation_nextToken' - An identifier that was returned from the previous call to this
-- operation, which you can use to return the next set of items in the
-- list.
--
-- 'mergedApiIdentifier', 'listTypesByAssociation_mergedApiIdentifier' - The identifier of the AppSync Merged API. This is generated by the
-- AppSync service. In most cases, Merged APIs (especially in your account)
-- only require the API ID value or ARN of the merged API. However, Merged
-- APIs in other accounts (cross-account use cases) strictly require the
-- full resource ARN of the merged API.
--
-- 'associationId', 'listTypesByAssociation_associationId' - The ID generated by the AppSync service for the source API association.
--
-- 'format', 'listTypesByAssociation_format' - The format type.
newListTypesByAssociation ::
  -- | 'mergedApiIdentifier'
  Prelude.Text ->
  -- | 'associationId'
  Prelude.Text ->
  -- | 'format'
  TypeDefinitionFormat ->
  ListTypesByAssociation
newListTypesByAssociation
  pMergedApiIdentifier_
  pAssociationId_
  pFormat_ =
    ListTypesByAssociation'
      { maxResults =
          Prelude.Nothing,
        nextToken = Prelude.Nothing,
        mergedApiIdentifier = pMergedApiIdentifier_,
        associationId = pAssociationId_,
        format = pFormat_
      }

-- | The maximum number of results that you want the request to return.
listTypesByAssociation_maxResults :: Lens.Lens' ListTypesByAssociation (Prelude.Maybe Prelude.Natural)
listTypesByAssociation_maxResults = Lens.lens (\ListTypesByAssociation' {maxResults} -> maxResults) (\s@ListTypesByAssociation' {} a -> s {maxResults = a} :: ListTypesByAssociation)

-- | An identifier that was returned from the previous call to this
-- operation, which you can use to return the next set of items in the
-- list.
listTypesByAssociation_nextToken :: Lens.Lens' ListTypesByAssociation (Prelude.Maybe Prelude.Text)
listTypesByAssociation_nextToken = Lens.lens (\ListTypesByAssociation' {nextToken} -> nextToken) (\s@ListTypesByAssociation' {} a -> s {nextToken = a} :: ListTypesByAssociation)

-- | The identifier of the AppSync Merged API. This is generated by the
-- AppSync service. In most cases, Merged APIs (especially in your account)
-- only require the API ID value or ARN of the merged API. However, Merged
-- APIs in other accounts (cross-account use cases) strictly require the
-- full resource ARN of the merged API.
listTypesByAssociation_mergedApiIdentifier :: Lens.Lens' ListTypesByAssociation Prelude.Text
listTypesByAssociation_mergedApiIdentifier = Lens.lens (\ListTypesByAssociation' {mergedApiIdentifier} -> mergedApiIdentifier) (\s@ListTypesByAssociation' {} a -> s {mergedApiIdentifier = a} :: ListTypesByAssociation)

-- | The ID generated by the AppSync service for the source API association.
listTypesByAssociation_associationId :: Lens.Lens' ListTypesByAssociation Prelude.Text
listTypesByAssociation_associationId = Lens.lens (\ListTypesByAssociation' {associationId} -> associationId) (\s@ListTypesByAssociation' {} a -> s {associationId = a} :: ListTypesByAssociation)

-- | The format type.
listTypesByAssociation_format :: Lens.Lens' ListTypesByAssociation TypeDefinitionFormat
listTypesByAssociation_format = Lens.lens (\ListTypesByAssociation' {format} -> format) (\s@ListTypesByAssociation' {} a -> s {format = a} :: ListTypesByAssociation)

instance Core.AWSRequest ListTypesByAssociation where
  type
    AWSResponse ListTypesByAssociation =
      ListTypesByAssociationResponse
  request overrides =
    Request.get (overrides defaultService)
  response =
    Response.receiveJSON
      ( \s h x ->
          ListTypesByAssociationResponse'
            Prelude.<$> (x Data..?> "nextToken")
            Prelude.<*> (x Data..?> "types" Core..!@ Prelude.mempty)
            Prelude.<*> (Prelude.pure (Prelude.fromEnum s))
      )

instance Prelude.Hashable ListTypesByAssociation where
  hashWithSalt _salt ListTypesByAssociation' {..} =
    _salt
      `Prelude.hashWithSalt` maxResults
      `Prelude.hashWithSalt` nextToken
      `Prelude.hashWithSalt` mergedApiIdentifier
      `Prelude.hashWithSalt` associationId
      `Prelude.hashWithSalt` format

instance Prelude.NFData ListTypesByAssociation where
  rnf ListTypesByAssociation' {..} =
    Prelude.rnf maxResults
      `Prelude.seq` Prelude.rnf nextToken
      `Prelude.seq` Prelude.rnf mergedApiIdentifier
      `Prelude.seq` Prelude.rnf associationId
      `Prelude.seq` Prelude.rnf format

instance Data.ToHeaders ListTypesByAssociation where
  toHeaders =
    Prelude.const
      ( Prelude.mconcat
          [ "Content-Type"
              Data.=# ( "application/x-amz-json-1.1" ::
                          Prelude.ByteString
                      )
          ]
      )

instance Data.ToPath ListTypesByAssociation where
  toPath ListTypesByAssociation' {..} =
    Prelude.mconcat
      [ "/v1/mergedApis/",
        Data.toBS mergedApiIdentifier,
        "/sourceApiAssociations/",
        Data.toBS associationId,
        "/types"
      ]

instance Data.ToQuery ListTypesByAssociation where
  toQuery ListTypesByAssociation' {..} =
    Prelude.mconcat
      [ "maxResults" Data.=: maxResults,
        "nextToken" Data.=: nextToken,
        "format" Data.=: format
      ]

-- | /See:/ 'newListTypesByAssociationResponse' smart constructor.
data ListTypesByAssociationResponse = ListTypesByAssociationResponse'
  { -- | An identifier that was returned from the previous call to this
    -- operation, which you can use to return the next set of items in the
    -- list.
    nextToken :: Prelude.Maybe Prelude.Text,
    -- | The @Type@ objects.
    types :: Prelude.Maybe [Type],
    -- | The response's http status code.
    httpStatus :: Prelude.Int
  }
  deriving (Prelude.Eq, Prelude.Read, Prelude.Show, Prelude.Generic)

-- |
-- Create a value of 'ListTypesByAssociationResponse' with all optional fields omitted.
--
-- Use <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/optics optics> to modify other optional fields.
--
-- The following record fields are available, with the corresponding lenses provided
-- for backwards compatibility:
--
-- 'nextToken', 'listTypesByAssociationResponse_nextToken' - An identifier that was returned from the previous call to this
-- operation, which you can use to return the next set of items in the
-- list.
--
-- 'types', 'listTypesByAssociationResponse_types' - The @Type@ objects.
--
-- 'httpStatus', 'listTypesByAssociationResponse_httpStatus' - The response's http status code.
newListTypesByAssociationResponse ::
  -- | 'httpStatus'
  Prelude.Int ->
  ListTypesByAssociationResponse
newListTypesByAssociationResponse pHttpStatus_ =
  ListTypesByAssociationResponse'
    { nextToken =
        Prelude.Nothing,
      types = Prelude.Nothing,
      httpStatus = pHttpStatus_
    }

-- | An identifier that was returned from the previous call to this
-- operation, which you can use to return the next set of items in the
-- list.
listTypesByAssociationResponse_nextToken :: Lens.Lens' ListTypesByAssociationResponse (Prelude.Maybe Prelude.Text)
listTypesByAssociationResponse_nextToken = Lens.lens (\ListTypesByAssociationResponse' {nextToken} -> nextToken) (\s@ListTypesByAssociationResponse' {} a -> s {nextToken = a} :: ListTypesByAssociationResponse)

-- | The @Type@ objects.
listTypesByAssociationResponse_types :: Lens.Lens' ListTypesByAssociationResponse (Prelude.Maybe [Type])
listTypesByAssociationResponse_types = Lens.lens (\ListTypesByAssociationResponse' {types} -> types) (\s@ListTypesByAssociationResponse' {} a -> s {types = a} :: ListTypesByAssociationResponse) Prelude.. Lens.mapping Lens.coerced

-- | The response's http status code.
listTypesByAssociationResponse_httpStatus :: Lens.Lens' ListTypesByAssociationResponse Prelude.Int
listTypesByAssociationResponse_httpStatus = Lens.lens (\ListTypesByAssociationResponse' {httpStatus} -> httpStatus) (\s@ListTypesByAssociationResponse' {} a -> s {httpStatus = a} :: ListTypesByAssociationResponse)

instance
  Prelude.NFData
    ListTypesByAssociationResponse
  where
  rnf ListTypesByAssociationResponse' {..} =
    Prelude.rnf nextToken
      `Prelude.seq` Prelude.rnf types
      `Prelude.seq` Prelude.rnf httpStatus
