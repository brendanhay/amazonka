{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE StrictData #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# OPTIONS_GHC -fno-warn-unused-binds #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- Derived from AWS service descriptions, licensed under Apache 2.0.

-- |
-- Module      : Amazonka.Athena.ListNotebookMetadata
-- Copyright   : (c) 2013-2023 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+amazonka@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
-- Displays the notebook files for the specified workgroup in paginated
-- format.
module Amazonka.Athena.ListNotebookMetadata
  ( -- * Creating a Request
    ListNotebookMetadata (..),
    newListNotebookMetadata,

    -- * Request Lenses
    listNotebookMetadata_filters,
    listNotebookMetadata_maxResults,
    listNotebookMetadata_nextToken,
    listNotebookMetadata_workGroup,

    -- * Destructuring the Response
    ListNotebookMetadataResponse (..),
    newListNotebookMetadataResponse,

    -- * Response Lenses
    listNotebookMetadataResponse_nextToken,
    listNotebookMetadataResponse_notebookMetadataList,
    listNotebookMetadataResponse_httpStatus,
  )
where

import Amazonka.Athena.Types
import qualified Amazonka.Core as Core
import qualified Amazonka.Core.Lens.Internal as Lens
import qualified Amazonka.Data as Data
import qualified Amazonka.Prelude as Prelude
import qualified Amazonka.Request as Request
import qualified Amazonka.Response as Response

-- | /See:/ 'newListNotebookMetadata' smart constructor.
data ListNotebookMetadata = ListNotebookMetadata'
  { -- | Search filter string.
    filters :: Prelude.Maybe FilterDefinition,
    -- | Specifies the maximum number of results to return.
    maxResults :: Prelude.Maybe Prelude.Natural,
    -- | A token generated by the Athena service that specifies where to continue
    -- pagination if a previous request was truncated.
    nextToken :: Prelude.Maybe Prelude.Text,
    -- | The name of the Spark enabled workgroup to retrieve notebook metadata
    -- for.
    workGroup :: Prelude.Text
  }
  deriving (Prelude.Eq, Prelude.Read, Prelude.Show, Prelude.Generic)

-- |
-- Create a value of 'ListNotebookMetadata' with all optional fields omitted.
--
-- Use <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/optics optics> to modify other optional fields.
--
-- The following record fields are available, with the corresponding lenses provided
-- for backwards compatibility:
--
-- 'filters', 'listNotebookMetadata_filters' - Search filter string.
--
-- 'maxResults', 'listNotebookMetadata_maxResults' - Specifies the maximum number of results to return.
--
-- 'nextToken', 'listNotebookMetadata_nextToken' - A token generated by the Athena service that specifies where to continue
-- pagination if a previous request was truncated.
--
-- 'workGroup', 'listNotebookMetadata_workGroup' - The name of the Spark enabled workgroup to retrieve notebook metadata
-- for.
newListNotebookMetadata ::
  -- | 'workGroup'
  Prelude.Text ->
  ListNotebookMetadata
newListNotebookMetadata pWorkGroup_ =
  ListNotebookMetadata'
    { filters = Prelude.Nothing,
      maxResults = Prelude.Nothing,
      nextToken = Prelude.Nothing,
      workGroup = pWorkGroup_
    }

-- | Search filter string.
listNotebookMetadata_filters :: Lens.Lens' ListNotebookMetadata (Prelude.Maybe FilterDefinition)
listNotebookMetadata_filters = Lens.lens (\ListNotebookMetadata' {filters} -> filters) (\s@ListNotebookMetadata' {} a -> s {filters = a} :: ListNotebookMetadata)

-- | Specifies the maximum number of results to return.
listNotebookMetadata_maxResults :: Lens.Lens' ListNotebookMetadata (Prelude.Maybe Prelude.Natural)
listNotebookMetadata_maxResults = Lens.lens (\ListNotebookMetadata' {maxResults} -> maxResults) (\s@ListNotebookMetadata' {} a -> s {maxResults = a} :: ListNotebookMetadata)

-- | A token generated by the Athena service that specifies where to continue
-- pagination if a previous request was truncated.
listNotebookMetadata_nextToken :: Lens.Lens' ListNotebookMetadata (Prelude.Maybe Prelude.Text)
listNotebookMetadata_nextToken = Lens.lens (\ListNotebookMetadata' {nextToken} -> nextToken) (\s@ListNotebookMetadata' {} a -> s {nextToken = a} :: ListNotebookMetadata)

-- | The name of the Spark enabled workgroup to retrieve notebook metadata
-- for.
listNotebookMetadata_workGroup :: Lens.Lens' ListNotebookMetadata Prelude.Text
listNotebookMetadata_workGroup = Lens.lens (\ListNotebookMetadata' {workGroup} -> workGroup) (\s@ListNotebookMetadata' {} a -> s {workGroup = a} :: ListNotebookMetadata)

instance Core.AWSRequest ListNotebookMetadata where
  type
    AWSResponse ListNotebookMetadata =
      ListNotebookMetadataResponse
  request overrides =
    Request.postJSON (overrides defaultService)
  response =
    Response.receiveJSON
      ( \s h x ->
          ListNotebookMetadataResponse'
            Prelude.<$> (x Data..?> "NextToken")
            Prelude.<*> ( x
                            Data..?> "NotebookMetadataList"
                            Core..!@ Prelude.mempty
                        )
            Prelude.<*> (Prelude.pure (Prelude.fromEnum s))
      )

instance Prelude.Hashable ListNotebookMetadata where
  hashWithSalt _salt ListNotebookMetadata' {..} =
    _salt
      `Prelude.hashWithSalt` filters
      `Prelude.hashWithSalt` maxResults
      `Prelude.hashWithSalt` nextToken
      `Prelude.hashWithSalt` workGroup

instance Prelude.NFData ListNotebookMetadata where
  rnf ListNotebookMetadata' {..} =
    Prelude.rnf filters
      `Prelude.seq` Prelude.rnf maxResults
      `Prelude.seq` Prelude.rnf nextToken
      `Prelude.seq` Prelude.rnf workGroup

instance Data.ToHeaders ListNotebookMetadata where
  toHeaders =
    Prelude.const
      ( Prelude.mconcat
          [ "X-Amz-Target"
              Data.=# ( "AmazonAthena.ListNotebookMetadata" ::
                          Prelude.ByteString
                      ),
            "Content-Type"
              Data.=# ( "application/x-amz-json-1.1" ::
                          Prelude.ByteString
                      )
          ]
      )

instance Data.ToJSON ListNotebookMetadata where
  toJSON ListNotebookMetadata' {..} =
    Data.object
      ( Prelude.catMaybes
          [ ("Filters" Data..=) Prelude.<$> filters,
            ("MaxResults" Data..=) Prelude.<$> maxResults,
            ("NextToken" Data..=) Prelude.<$> nextToken,
            Prelude.Just ("WorkGroup" Data..= workGroup)
          ]
      )

instance Data.ToPath ListNotebookMetadata where
  toPath = Prelude.const "/"

instance Data.ToQuery ListNotebookMetadata where
  toQuery = Prelude.const Prelude.mempty

-- | /See:/ 'newListNotebookMetadataResponse' smart constructor.
data ListNotebookMetadataResponse = ListNotebookMetadataResponse'
  { -- | A token generated by the Athena service that specifies where to continue
    -- pagination if a previous request was truncated. To obtain the next set
    -- of pages, pass in the @NextToken@ from the response object of the
    -- previous page call.
    nextToken :: Prelude.Maybe Prelude.Text,
    -- | The list of notebook metadata for the specified workgroup.
    notebookMetadataList :: Prelude.Maybe [NotebookMetadata],
    -- | The response's http status code.
    httpStatus :: Prelude.Int
  }
  deriving (Prelude.Eq, Prelude.Read, Prelude.Show, Prelude.Generic)

-- |
-- Create a value of 'ListNotebookMetadataResponse' with all optional fields omitted.
--
-- Use <https://hackage.haskell.org/package/generic-lens generic-lens> or <https://hackage.haskell.org/package/optics optics> to modify other optional fields.
--
-- The following record fields are available, with the corresponding lenses provided
-- for backwards compatibility:
--
-- 'nextToken', 'listNotebookMetadataResponse_nextToken' - A token generated by the Athena service that specifies where to continue
-- pagination if a previous request was truncated. To obtain the next set
-- of pages, pass in the @NextToken@ from the response object of the
-- previous page call.
--
-- 'notebookMetadataList', 'listNotebookMetadataResponse_notebookMetadataList' - The list of notebook metadata for the specified workgroup.
--
-- 'httpStatus', 'listNotebookMetadataResponse_httpStatus' - The response's http status code.
newListNotebookMetadataResponse ::
  -- | 'httpStatus'
  Prelude.Int ->
  ListNotebookMetadataResponse
newListNotebookMetadataResponse pHttpStatus_ =
  ListNotebookMetadataResponse'
    { nextToken =
        Prelude.Nothing,
      notebookMetadataList = Prelude.Nothing,
      httpStatus = pHttpStatus_
    }

-- | A token generated by the Athena service that specifies where to continue
-- pagination if a previous request was truncated. To obtain the next set
-- of pages, pass in the @NextToken@ from the response object of the
-- previous page call.
listNotebookMetadataResponse_nextToken :: Lens.Lens' ListNotebookMetadataResponse (Prelude.Maybe Prelude.Text)
listNotebookMetadataResponse_nextToken = Lens.lens (\ListNotebookMetadataResponse' {nextToken} -> nextToken) (\s@ListNotebookMetadataResponse' {} a -> s {nextToken = a} :: ListNotebookMetadataResponse)

-- | The list of notebook metadata for the specified workgroup.
listNotebookMetadataResponse_notebookMetadataList :: Lens.Lens' ListNotebookMetadataResponse (Prelude.Maybe [NotebookMetadata])
listNotebookMetadataResponse_notebookMetadataList = Lens.lens (\ListNotebookMetadataResponse' {notebookMetadataList} -> notebookMetadataList) (\s@ListNotebookMetadataResponse' {} a -> s {notebookMetadataList = a} :: ListNotebookMetadataResponse) Prelude.. Lens.mapping Lens.coerced

-- | The response's http status code.
listNotebookMetadataResponse_httpStatus :: Lens.Lens' ListNotebookMetadataResponse Prelude.Int
listNotebookMetadataResponse_httpStatus = Lens.lens (\ListNotebookMetadataResponse' {httpStatus} -> httpStatus) (\s@ListNotebookMetadataResponse' {} a -> s {httpStatus = a} :: ListNotebookMetadataResponse)

instance Prelude.NFData ListNotebookMetadataResponse where
  rnf ListNotebookMetadataResponse' {..} =
    Prelude.rnf nextToken
      `Prelude.seq` Prelude.rnf notebookMetadataList
      `Prelude.seq` Prelude.rnf httpStatus
